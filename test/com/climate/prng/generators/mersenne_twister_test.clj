(ns com.climate.prng.generators.mersenne-twister-test
  (:require
    [clojure.test :refer :all]
    [clojure.java.io :refer [resource]]
    [clojure.string :refer [split]]
    [criterium.core :refer [quick-bench]]
    [com.climate.prng.core :as prng]
    [com.climate.prng.generators.mersenne-twister :as mt])
  (:import
    [com.climate.prng.generators.mersenne_twister
     BitShift MersenneTwisterState]))

(defn mt19937-64-reference
  "Sample outputs generated by the reference implementation of the
  64-bit MT19937 generator.

  This function returns a map that contains the following entries:

    :seed
        A long[4] array.
    :expected-longs
        1000-element sequence of longs.
    :expected-doubles
        1000-element sequence of doubles. These doubles are not exact
        because they are stored as strings in the resource.

  The output sequences were generated by the following procedure:

    (0) The generator was constructed and seeded using the 4-element
        seed array.
    (1) 1000 longs were sequentially generated immediately after step
        (0).
    (2) 1000 doubles were sequentially generated immediately after step
        (1).

  The reference implementation and sample outputs are from
  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html"
  []
  (let [seed             (long-array [0x12345 0x23456 0x34567 0x45678])
        words            (-> (resource "mt19937-64.out.txt")
                           (slurp)
                           (split #"\s+"))
        ; The sample output file contains strings that represent
        ; unsigned 64-bit integers. Convert these to signed longs that
        ; have the same binary representation.
        parse-long       #(.longValue (BigInteger. % 10))
        expected-longs   (->> (nthnext words 4)
                           (take 1000)
                           (map parse-long))
        parse-double     #(Double/parseDouble %)
        expected-doubles (->> (nthnext words 10008)
                           (take 1000)
                           (map parse-double))]
    {:seed seed
     :expected-longs expected-longs
     :expected-doubles expected-doubles}))

(deftest test-against-reference-implementation
  (testing
    (str
      "This implementation generates the same outputs as the reference "
      "implementation in C")
    (let [{:keys [seed expected-longs expected-doubles]} (mt19937-64-reference)
          states (iterate prng/next-state (mt/seed-state seed))
          actual-longs (->> states
                         (take (count expected-longs))
                         (mapv prng/->long))
          ; Emulate genrand64_real2 function in mt19937-64.c
          ->double* (fn [state]
                      (-> state
                        (prng/->long)
                        (BitShift/unsignedShiftRight 11)
                        (Long/toHexString)
                        (BigInteger. 16)
                        (* (/ 1.0 9007199254740992.0))))
          actual-doubles (->> states
                           (drop (count expected-longs))
                           (take (count expected-doubles))
                           (mapv ->double*))
          ; The reference file does not exactly represent floating-point
          ; values, so test approximate equality within epsilon.
          epsilon 0.000001
          within-epsilon (fn [x y] (< (Math/abs (- x y)) epsilon))]
      (is (and
            (= expected-longs actual-longs)
            (every?
              true?
              (map within-epsilon expected-doubles actual-doubles)))))))

(deftest test-seed-state
  (testing "seed-state returns an object that satisfies PRNGState protocol"
    (are [seed] (satisfies? prng/PRNGState (mt/seed-state seed))
         0
         (long 1234567)
         (long-array [0x12345 0x23456 0x34567 0x45678])))
  (testing "seed-state is a pure function that creates a new object"
    (are [seed] (let [state-a (mt/seed-state seed)
                      state-b (mt/seed-state seed)]
                  (not (identical? state-a state-b))
                  (= state-a state-b)
                  (= (hash state-a) (hash state-b)))
         0
         (long 1234567)
         (long-array [0x12345 0x23456 0x34567 0x45678])))
  (testing "seed-state does not hold a reference to the seed argument"
    (let [seed-a (long-array [1 2 Long/MAX_VALUE -72 Long/MIN_VALUE 0 0 5])
          seed-b (into-array Long/TYPE (seq seed-a))
          state-a (mt/seed-state seed-a)
          state-b (mt/seed-state seed-b)]
      (is (= state-a state-b))
      ; mutating the provided seed does not change the state
      (aset-long seed-a 0 (inc (aget seed-a 0)))
      (is (= state-a state-b))
      (is (= (prng/->long state-a) (prng/->long state-b)))))
  (testing "seed-state throws an exception when seed argument is invalid"
    (are [seed] (thrown? IllegalArgumentException (mt/seed-state seed))
         nil
         (long-array 0) ; empty array is not allowed
         (int-array [0x12345 0x23456 0x34567 0x45678]))))

(deftest test-clone
  (testing "clone returns a new object that equals and hashes like the original"
    (let [a (mt/seed-state 123457)
          b (prng/clone a)
          c (prng/clone a)]
      (is (= a b c))
      (is (= (hash a) (hash b) (hash c)))
      (is (not (identical? a b)))
      (is (not (identical? a c)))
      (is (not (identical? b c)))
      ; mutating the copy does not affect the original
      (is (let [idx 0
                backup-value (.get a idx)]
            (.set b idx (inc backup-value))
            (= (.get a idx) backup-value)))))
  (testing "clone is thread-safe"
    (let [state (mt/seed-state 1234567)
          as (doall (map agent (repeat 10000 state)))]
      (doseq [a as] (send-off a prng/clone))
      (apply await as)
      (is (every? #(= % state) (map deref as))))))

(deftest test-next-state
  (testing "next-state returns a new, distinct state"
    (let [state (mt/seed-state 1234567)]
      (not= state (prng/next-state state))))
  (testing "next-state is a pure function"
    (let [state (mt/seed-state 1234567)]
      (= (prng/next-state state) (prng/next-state state))))
  (testing "next-state is thread-safe"
    (let [state (mt/seed-state 1234567)
          as (doall (map agent (repeat 10000 state)))]
      (doseq [a as] (send-off a prng/next-state))
      (apply await as)
      (is (= 1 (count (distinct (map deref as))))))))

(deftest test-jump-state
  (testing "jump-state jumps ahead by the requested number of iterations"
    (let [state (mt/seed-state 1234567)
          nth-state (fn [state n]
                      (->> state
                        (iterate prng/next-state)
                        (drop n)
                        (first)))]
      (are [jump-size] (= (prng/jump-state state jump-size)
                          (nth-state state jump-size))
           0
           1
           100
           (dec mt/K)
           mt/K
           (inc mt/K)
           32768
           50000 ; between 32768 and 65536
           65536
           100000)))
  (testing "jump-state is commutative"
    (let [state (mt/seed-state 1234567)]
      (is (= ; these two sequences of jump sizes are permutations
            (reduce #(prng/jump-state %1 %2) state [100 1000 1 10])
            (reduce #(prng/jump-state %1 %2) state [1 10 1000 100])))))
  (testing "jump-state is associative"
    (let [state (mt/seed-state 1234567)]
      (is (= ; these two sequences of jump sizes sum to the same total
            (reduce #(prng/jump-state %1 %2) state [100 1000 1 10])
            (reduce #(prng/jump-state %1 %2) state [70 1041])))))
  (testing "jump-state throws exception when jump-size is not an integer"
    (let [state (mt/seed-state 1234567)
          jump-size 100.0]
      (is (thrown?
            IllegalArgumentException
            (prng/jump-state state jump-size)))))
  (testing "jump-state throws exception when jump-size is negative"
    (let [state (mt/seed-state 1234567)
          jump-size -1]
      (is (thrown?
            IllegalArgumentException
            (prng/jump-state state jump-size)))))
  (testing "jump-state works with *remainder-polynomials* binding"
    (binding [mt/*remainder-polynomials* (hash-map)] ; empty map
      (let [state (mt/seed-state 1234567)
            nth-state (fn [state n]
                        (->> state
                          (iterate prng/next-state)
                          (drop n)
                          (first)))]
        (are [jump-size] (= (prng/->long
                              (prng/jump-state state jump-size))
                            (prng/->long
                              (nth-state state jump-size)))
           1
           100
           32768)))))

(deftest test-state->long
  (testing "->long returns a long"
    (let [n 1000
          valid? #(and
                    (integer? %)
                    (instance? Long %))]
      (are [initial-state] (->> initial-state
                             (iterate prng/next-state)
                             (map prng/->long)
                             (take n)
                             (every? valid?))
         (mt/seed-state 1234567)
         (mt/seed-state Long/MAX_VALUE)
         (mt/seed-state (long-array [0x12345 0x23456 0x34567 0x45678])))))
  (testing "->long is a pure function"
    (are [state] (let [state-backup (prng/clone state)]
                   (and
                     (= (prng/->long state) (prng/->long state))
                     (= state state-backup)))
         (mt/seed-state 1234567)
         (mt/seed-state Long/MAX_VALUE)
         (mt/seed-state (long-array [0x12345 0x23456 0x34567 0x45678])))))

(deftest test-state->double
  (testing "->double returns a double on the unit interval"
    (let [n 1000
          valid? #(and
                    (float? %)
                    (instance? Double %)
                    (> % 0.0)
                    (< % 1.0))]
      (are [initial-state] (->> initial-state
                             (iterate prng/next-state)
                             (map prng/->double)
                             (take n)
                             (every? valid?))
         (mt/seed-state 1234567)
         (mt/seed-state Long/MAX_VALUE)
         (mt/seed-state (long-array [0x12345 0x23456 0x34567 0x45678])))))
  (testing "->double is a pure function"
    (are [state] (let [state-backup (prng/clone state)]
                   (and
                     (= (prng/->double state) (prng/->double state))
                     (= state state-backup)))
         (mt/seed-state 1234567)
         (mt/seed-state Long/MAX_VALUE)
         (mt/seed-state (long-array [0x12345 0x23456 0x34567 0x45678])))))

(deftest ^:benchmark benchmark-next-state
  (with-test-out
    (testing "Benchmarking next-state function"
      (println (testing-contexts-str))
      (let [state (mt/seed-state 1234567)]
        (quick-bench (prng/next-state state))))))

(deftest ^:benchmark benchmark-jump-state
  (with-test-out
    (testing "Benchmarking jump-state function"
      (println (testing-contexts-str))
      (let [state (mt/seed-state 1234567)
            jump-size 1000000000] ; 1 billion!
        (quick-bench (prng/jump-state state jump-size))))))
